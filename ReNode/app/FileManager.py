

import os
import json
from datetime import datetime
from ReNode.app.config import Config

class FileManagerHelper:
	@staticmethod
	def getWorkDir():
		return Config.get_str("workdir","main")
	
	@staticmethod
	def getSDKSourceDir():
		return Config.get_str("sdkdir","main")
	
	@staticmethod
	def allocateSDKSourceDir():
		from PyQt5.QtWidgets import QFileDialog

		wd = FileManagerHelper.getWorkDir()
		#up to tree
		pcheck = os.path.join(wd,"..\\..\\src")
		if os.path.exists(pcheck): return pcheck

		pcheck = os.path.join(wd,"src")
		if not os.path.exists(pcheck): 
			dsel = ""
			while dsel == "":
				dsel = QFileDialog.getExistingDirectory(None,"Укажите путь до исходников ReSDK (SRC папки)",".\\..\\")
			pcheck = dsel
		return pcheck

	@staticmethod
	def getGraphPathRelative(path):
		"""Получает относительный путь к графу (по отношению к workdir)""" 
		if os.path.isdir(path):
			raise Exception(f"Path must be file: {path}")
		if os.path.isabs(path):
			return os.path.relpath(path, FileManagerHelper.getWorkDir())
		return ""


	#region root prefix
	@staticmethod
	def graphPathToRoot(path):
		if not FileManagerHelper.graphPathIsRoot(path):
			rp = os.path.relpath(path,FileManagerHelper.getWorkDir())
			if rp.startswith("..\\"):
				rp = rp.lstrip("..\\")
				if path in rp:
					path = rp
			else:
				if rp in path:
					path = rp
			path = "root:"+path
		return path
	@staticmethod
	def graphPathToClear(path):
		if FileManagerHelper.graphPathIsRoot(path):
			path = path[len('root:'):]
		if path.startswith("\\"):
			path = path[1:]
		return path
	@staticmethod
	def graphPathIsRoot(path):
		return path.startswith("root:")
	@staticmethod
	def graphPathExists(path):
		if FileManagerHelper.graphPathIsRoot(path):
			return os.path.exists(FileManagerHelper.graphPathGetReal(path))
		else:
			return os.path.exists(path)
	@staticmethod
	def graphPathGetReal(path,returnAbsolute=False):
		pts = os.path.join(
				FileManagerHelper.getWorkDir(),
				FileManagerHelper.graphPathToClear(path)
			)
		if returnAbsolute:
			return os.path.abspath(pts)
		else:
			return pts
	#endregion

	@staticmethod
	def getFolderCompiledScripts():
		"""Получает путь скомпилирвоанных скриптов"""
		return os.path.join(FileManagerHelper.getSDKSourceDir(),"host\\ReNode\\compiled")
	
	@staticmethod
	def getCompiledScriptFilename(iData):
		return f'{iData["type"]}.{iData["parent"]}.{iData["classname"]}.sqf'

	@staticmethod
	def generateScriptLoader(excludeGuid=None):
		from ReNode.app.application import Application
		compiled_folder_path = FileManagerHelper.getFolderCompiledScripts()
		rootDir = FileManagerHelper.getWorkDir()
		logger = Application.refObject.logger

		loader_path = os.path.join(compiled_folder_path,"script_list.hpp")
		with open(loader_path, "w+", encoding="utf-8") as file:
			file.write("//generated by ReNode {}".format(Application.getVersionString()))
			files = FileManagerHelper.find_files(compiled_folder_path,"sqf")
			doRemovePrefix = compiled_folder_path.startswith(".\\")
			for filepath in files:
				meta = FileManagerHelper.getCompiledScriptMetainfo(filepath)
				if meta:
					if not meta.get('valid',True):
						os.remove(filepath)
						logger.info(f"Removed invalid compiled file: {filepath}")
						continue
					#get graph
					#! регенерация должна происходить в другом месте...
					# if excludeGuid and meta.get("guid")!=excludeGuid:
					# 	data = FileManagerHelper.loadSessionJson(os.path.join(rootDir,meta['path']))
					# 	logger.debug("Checking graph: {}".format(meta['path']))
					# 	graphGuid = data['graph']['info'].get('compiledGUID','')
					# 	if meta['guid'] != graphGuid:
					# 		logger.debug("Obsolete guid. Regenerating...")

				if doRemovePrefix:
					filepath = filepath[2:]
				file.write(f'\n{filepath}')
		

	@staticmethod
	def getCompiledScriptMetainfo(path):
		"""Возвращает None если граф не найден или структура не соответствует правилам
		Иначе возвращает словарь с ключами: guid(str), rooted_path(str),valid(bool), date(datetime)
		"""
		if not os.path.exists(path): return None
		dictRet = {}
		timeformat = '%Y-%m-%d %H:%M:%S.%f' #strptime format
		with open(path,"r",encoding='utf-8') as file:
			#parse compile metainfo
			sysDat = file.readline()
			if not sysDat.startswith("//src:"): return None
			sysDat = sysDat[:-1] #rem endl char
			pats = sysDat.split(":")
			if len(pats)!=4: return None
			if pats[0]!="//src": return None
			if pats[2]!="root": return None
			_rootedPath = "root:" + pats[3]
			dictRet['guid'] = pats[1] #гуид компиляции
			dictRet['path'] = _rootedPath #путь графа (with root)
			dictRet['valid'] = FileManagerHelper.graphPathExists(_rootedPath) #актуальный ли файл

			#parse compile date
			cd = file.readline()
			if not cd.startswith("//gdate:"): return None
			cd = cd[:-1] #rem endl char
			cdDate= cd[len("//gdate:"):]
			dictRet['date'] = datetime.strptime(cdDate,timeformat)
		return dictRet
			

	@staticmethod
	def find_files(root_dir, extension,relToRootDir=False):
		"""Поиск всех файлов с указанным расширенем, начиная от папки root_dir. Расширение указывается без точки"""
		files = []
		for dirpath, dirnames, filenames in os.walk(root_dir):
			if relToRootDir:
					dirpath = os.path.relpath(dirpath,root_dir)
			for filename in filenames:
				if filename.endswith(f".{extension}"):
					files.append(os.path.join(dirpath, filename))
		return files

	# получить пути всех графов
	@staticmethod
	def getAllGraphPathes():
		"""Возвращает пути графов относительно workdir. Все пути в чистом виде (graphPathIsRoot == False)"""
		rootDir = FileManagerHelper.getWorkDir()
		return FileManagerHelper.find_files(rootDir,"graph")
	
	@staticmethod
	def loadSessionJson(file_path) -> dict|None:
		"""Загружает граф из json файла в словарь и возвращает его"""
		layout_data = None
		try:
			with open(file_path,encoding='utf-8') as data_file:
				layout_data = json.load(data_file)
		except Exception as e:
			layout_data = None

		return layout_data
	
	@staticmethod
	def default_ser_(obj):
		if isinstance(obj, set):
			return list(obj)
		return obj

	@staticmethod
	def updateSessionJson(file_path,action_):
		try:
			with open(file_path, 'r+',encoding='utf-8') as file_out:
				lay = json.load(file_out)
				if action_ == None or not callable(action_): raise Exception("Action for update session is empty or not callable")
				if action_(lay):
					file_out.seek(0)
					file_out.truncate()

					json.dump(
						lay,
						file_out,
						indent=2,
						separators=(',', ':'),
						default=FileManagerHelper.default_ser_,
						ensure_ascii=False
					)

			return True
		except Exception as e:
			print("Exception on update session. Reason: {}".format(e))
			return False
	
	@staticmethod
	def getCompareCompiledGraphsInfo():
		"""
			Массив словарей:
				"guid_actual" - bool, if is graph compiled\n
				"graph_path" - str, graph path from FileManagerHelper.getAllGraphPathes() (without rooted pref.)\n
				"graph_guid" - str, located guid inside graph file\n
				"compile_guid" - str, located guid inside header of compiled file\n
				"compile_date" - str, datetime located inside compiled file\n
				"exists_graph" - bool, validation from compiled to graph\n
		"""
		from ReNode.app.application import Application
		logger = Application.refObject.logger
		factory = Application.refObject.mainWindow.nodeFactory
		allgraphs = FileManagerHelper.getAllGraphPathes()
		ret = []
		# грузим граф
		for graphPath in allgraphs:
			sess = FileManagerHelper.loadSessionJson(graphPath)
			idat = sess['graph']['info']
			graphVersion = idat.get('graphVersion',-1)
			lastguid = idat.get("compiledGUID")
			fname = FileManagerHelper.getCompiledScriptFilename(idat)
			fnameComp = os.path.join(FileManagerHelper.getFolderCompiledScripts(),fname)
			
			compMeta = FileManagerHelper.getCompiledScriptMetainfo(fnameComp)
			if compMeta == None: compMeta = {}
			
			ret.append({
				"guid_actual": lastguid == compMeta.get('guid'), 
				"graph_path": graphPath,
				"graph_guid": lastguid,
				"compile_guid": compMeta.get("guid","none"),

				"compile_date": compMeta.get("date","none"),
				"exists_graph": compMeta.get("valid",False),

				"gver": graphVersion,
				"gver_actual": graphVersion == factory.graphVersion,
			})

		return ret
	
	@staticmethod
	def getCompiledScriptMetainfoByInfoData(idat):
		"""
			{
			 	guid(str), rooted_path(str),valid(bool), date(datetime)
			}
		"""
		fname = FileManagerHelper.getCompiledScriptFilename(idat)
		fnameComp = os.path.join(FileManagerHelper.getFolderCompiledScripts(),fname)
		
		compMeta = FileManagerHelper.getCompiledScriptMetainfo(fnameComp)
		if compMeta == None: compMeta = {}
		return compMeta

	@staticmethod
	def getBuildRequiredGraphs():
		"""Возвращает список графов, которые необходимо пересобрать"""
		return [data['graph_path'] for data in FileManagerHelper.getCompareCompiledGraphsInfo() if not data.get('guid_actual') or not data.get('exists_graph') or not data.get("gver_actual")]

		
	# @staticmethod
	# def openGraphHandle(file_path):
	# 	"""Открывает файл и возвращает его дескриптор+json"""
	# 	layout_data = None
	# 	fhandle = None
	# 	try:
	# 		fhandle = open(file_path,mode="r+",encoding='utf-8')
	# 		layout_data = json.load(fhandle)
	# 	except Exception as e:
	# 		layout_data = None

	# 	return layout_data,fhandle